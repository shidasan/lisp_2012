(setq PI 3.1416)
(setq WIDTH 32)
(setq HEIGHT 32)
(setq NSUBSAMPLES 2)
(setq NAO_SAMPLES 4)

(defmacro inc (x) (list 'setq x (list '+ x 1)))
(defun vx (v) (svref v 0))
(defun vy (v) (svref v 1))
(defun vz (v) (svref v 2))

(defun vadd (v0 v1)
 (vector (+ (vx v0) (vx v1))
         (+ (vy v0) (vy v1))
         (+ (vz v0) (vz v1))))

(defun vsub (v0 v1)
 (vector (- (vx v0) (vx v1))
         (- (vy v0) (vy v1))
         (- (vz v0) (vz v1))))

(defun vmul (v0 v1)
 (vector (* (vx v0) (vx v1))
         (* (vy v0) (vy v1))
         (* (vz v0) (vz v1))))

(defun vcross (a b)
 (vector (- (* (vy a) (vz b)) (* (vz a) (vy b)))
         (- (* (vz a) (vx b)) (* (vx a) (vz b)))
         (- (* (vx a) (vy b)) (* (vy a) (vx b)))))

(defun vdot (v0 v1) (+ (* (svref v0 0) (svref v1 0)) (* (svref v0 1) (svref v1 1)) (* (svref v0 2) (svref v1 2))))

(defun sq (f) (* f f))

(defun vlen (a)
 (sqrt (+ (sq (svref a 0)) (sq (svref a 1)) (sq (svref a 2)))))

(defun vnormalize (bc)
 (let* ((d (vdot bc bc))
        (l (sqrt d)))
  (if (> l 0.00000000001)
   (vector (/ (svref bc 0) l) (/ (svref bc 1) l) (/ (svref bc 2) l))
   bc)))


(defun sphere (x y z r)
 (vector (vector x y z) r))

(setq spheres (vector 
               (sphere -2.0 0.0 -3.5 0.5)
               (sphere -0.5 0.0 -3.0 0.5)
               (sphere 1.0 0.0 -2.2 0.5)))
(setq plane (vector
             (vector 0.0 -0.5 0.0)
             (vector 0.0 1.0 0.0)))

(defun interSectsSphere (s isect)
 (let* ((rs (vsub (svref isect 0) (svref s 0)))
        (b (vdot rs (svref isect 1)))
        (c (- (vdot rs rs) (* (svref s 1) (svref s 1))))
        (d (- (* b b) c))
        (tt 0))
  (if (> d 0) (progn
   (setq tt (- (- b) (sqrt d)))
    (if (and (> tt 0) (< tt (svref isect 4)))
     (progn
     (system::svstore isect 4 tt)
     (system::svstore isect 5 T)
     (system::svstore isect 2 (vadd (svref isect 0) (vmul (svref isect 1) (vector tt tt tt))))
     (system::svstore isect 3 (vsub (svref isect 2) (svref s 0)))
     (system::svstore isect 3 (vnormalize (svref isect 3))))
     nil))
   nil))
 isect)

(defun interSectsPlane (plane isect)
 (let* ((d (* (- 1) (vdot (svref plane 0) (svref plane 1))))
        (v (vdot (svref isect 1) (svref plane 1))))
  (if (/= v 0)
   (progn
   (let ((tt (* (- 1) (/ (+ (vdot (svref isect 0) (svref plane 1)) d) v))))
    (if (and (> tt 0.0) (< tt (svref isect 4)))
	 (progn
     (system::svstore isect 4 tt)
     (system::svstore isect 5 T)
     (system::svstore isect 2 (vadd (svref isect 0) (vmul (svref isect 1) (vector tt tt tt))))
     (system::svstore isect 3 (vector (vx (svref plane 1)) (vy (svref plane 1)) (vz (svref plane 1)))))
	 nil)
	))
   nil))
 isect)

(defun getOrthoBasis (normal)
 (let ((basis0 (vector 0 0 0))
       (basis1x 0)
       (basis1y 0)
       (basis1z 0)
       (basis2 (vector (vx normal) (vy normal) (vz normal))))
  (cond 
   ((and (< (vx normal) 0.6) (> (vx normal) (- 0.6)))
    (setq basis1x 1))
   ((and (< (vy normal) 0.6) (> (vy normal) (- 0.6)))
    (setq basis1y 1))
   ((and (< (vz normal) 0.6) (> (vz normal) (- 0.6)))
    (setq basis1z 1))
   (otherwise
    (setq basis1x 1)))
  (setq basis0 (vcross (vector basis1x basis1y basis1z) basis2))
  (setq basis0 (vnormalize basis0))
  (setq basis1 (vcross basis2 basis0))
  (setq basis1 (vnormalize basis1))
  (vector basis0 basis1 basis2)))

(defun getAmbientOcclusion (isect)
 (let* ((ambientOcclusion (vector 0.0 0.0 0.0))
        (i 0)
        (j 0)
        (ntheta NAO_SAMPLES)
        (nphi NAO_SAMPLES)
        (eps 0.0001)
        (basis (getOrthoBasis (svref isect 3)))
        (occlsect (make-array '(6)))
        (hitCount 0))
  (system::svstore occlsect 0 (vector 
                        (+ (vx (svref isect 2)) (* eps (vx (svref isect 3))))
                        (+ (vy (svref isect 2)) (* eps (vy (svref isect 3))))
                        (+ (vz (svref isect 2)) (* eps (vz (svref isect 3))))))
  (system::svstore occlsect 1 (vector 0.0 0.0 0.0))
  (system::svstore occlsect 2 (vector 0.0 0.0 0.0))
  (system::svstore occlsect 3 (vector 0.0 0.0 0.0))
  (setq j 0)
  (loop
   (if (>= j ntheta) (return)
   (progn
   (setq i 0)
   (loop
	(if (>= i nphi) (return)
	 (progn
     (let* ((theta (sqrt (random 1.0)))
            (phi (* 2.0 PI (random 1.0)))
            (x (* (cos phi) theta))
            (y (* (sin phi) theta))
            (z (sqrt (- 1.0 (* theta theta)))))
      (system::svstore occlsect 4 100000000000)
      (system::svstore occlsect 5 nil)
      (system::svstore occlsect 1
       (vector
         (+ (* x (vx (svref basis 0))) (* y (vx (svref basis 1))) (* z (vx (svref basis 2))))
         (+ (* x (vy (svref basis 0))) (* y (vy (svref basis 1))) (* z (vy (svref basis 2))))
         (+ (* x (vz (svref basis 0))) (* y (vz (svref basis 1))) (* z (vz (svref basis 2))))))
      (setq occlsect (interSectsSphere (svref spheres 0) occlsect))
      (setq occlsect (interSectsSphere (svref spheres 1) occlsect))
      (setq occlsect (interSectsSphere (svref spheres 2) occlsect))
      (setq occlsect (interSectsPlane plane occlsect))
      (if (svref occlsect 5)
       (setq hitCount (+ hitCount 1)) nil))
     (setq i (+ i 1)))))
   (setq j (+ j 1)))))
  (let ((occlusionRatio (/ (- (* ntheta nphi) hitCount) (* ntheta nphi))))
   (vector occlusionRatio occlusionRatio occlusionRatio))))

(defun clamp (value)
 (let ((i (floor (* value 255.5))))
  (cond ((> i 255) (setq i 255))
   ((< i 0) (setq i 0))
   (T i))
  i))

(defun render (byteImage width height numberOfSubSamples)
 (let* ((fimg (make-array (list (* width height 3))))
        (isect (make-array '(6)))
        (yy 0)
        (xx 0)
    (vv 0)
    (u 0)
    (ambientOcclusion nil)
    (p 0)
    (p1 0)
    (num 0))
   (system::svstore isect 0 (vector 0.0 0.0 0.0))
   (system::svstore isect 1 (vector 0.0 0.0 0.0))
   (system::svstore isect 2 (vector 0.0 0.0 0.0))
   (system::svstore isect 3 (vector 0.0 0.0 0.0))
   (loop
	(if (>= yy height) (return)
	 (progn
    (setq xx 0)
    (loop
	 (if (>= xx width) (return)
	  (progn
     (setq vv 0)
     (loop
	  (if (>= vv numberOfSubSamples) (return)
	   (progn
      (setq u 0)
      (loop
	   (if (>= u numberOfSubSamples) (return)
		(progn
       (system::svstore isect 1 (vector 
                        (/ (+ xx (- (/ u numberOfSubSamples) (/ width 2.0))) (/ width 2.0))
                        (- (/ (+ yy (- (/ vv numberOfSubSamples) (/ height 2.0))) (/ height 2.0)))
                        (- 1.0)))
       (system::svstore isect 4 1000000000)
       (system::svstore isect 5 nil)
       (system::svstore isect 1 (vnormalize (svref isect 1)))
       (setq isect (interSectsSphere (svref spheres 0) isect))
       (setq isect (interSectsSphere (svref spheres 1) isect))
       (setq isect (interSectsSphere (svref spheres 2) isect))
       (setq isect (interSectsPlane plane isect))
       (if (svref isect 5)
        (progn 
        (setq ambientOcclusion (getAmbientOcclusion isect))
        (setq p (* 3 (+ (* yy width) xx)))
        (system::svstore fimg p (+ (svref fimg p) (svref ambientOcclusion 0)))
        (system::svstore fimg (+ p 1) (+ (svref fimg (+ p 1)) (svref ambientOcclusion 1)))
        (system::svstore fimg (+ p 2) (+ (svref fimg (+ p 2)) (svref ambientOcclusion 2))))
        nil
       )
       (setq u (+ u 1)))))
      (setq vv (+ vv 1)))))
     (setq p1 (* 3 (+ (* yy width) xx)))
     (setq num (* numberOfSubSamples numberOfSubSamples))
     (system::svstore fimg p1 (/ (svref fimg p1) num))
     (system::svstore fimg (+ p1 1) (/ (svref fimg (+ p1 1)) num))
     (system::svstore fimg (+ p1 2) (/ (svref fimg (+ p1 2)) num))
     (system::svstore byteImage p1 (clamp (svref fimg p1)))
     (system::svstore byteImage (+ p1 1) (clamp (svref fimg (+ p1 1))))
     (system::svstore byteImage (+ p1 2) (clamp (svref fimg (+ p1 2))))
     (setq xx (+ xx 1)))))
    (setq yy (+ yy 1))))
    )))
(defun run ()
  (let ((img (make-array (list (* WIDTH HEIGHT 3))))
        (i 0))
    (render img WIDTH HEIGHT NSUBSAMPLES)
    (format T "~A~%~A ~A~%~A~%" "P3" WIDTH HEIGHT 255)
    (loop
	 (if (>= i (* WIDTH HEIGHT 3)) (return)
	  (progn
     (format T "~A " (svref img i))
     (setq i (+ i 1)))))
    (format T "~%")
    ))
(run)
